package team

import (
	"fmt"
	"net/url"
	"sort"
)

templ methodicalAssociations(phrases map[string]map[string]string) {
	<section class="section leadership-section">
		<div class="container">
			for _, sectionName := range getSectionNames(phrases) {
				<div class="section-title animate-on-scroll">
					<h2>{ phrases[sectionName]["title"] }</h2>
					<p>{ phrases[sectionName]["subtitle"] }</p>
				</div>
				for row := 1; row <= 3; row++ {
					<div class="row g-4 mb-5">
						for col := 1; col <= 4; col++ {
							if name, exists := phrases[sectionName][fmt.Sprintf("teacher%d_%d_name", row, col)]; exists {
								<div class="col-lg-3 col-md-6">
									<div class="leader-card team-card-clickable animate-on-scroll">
										<div class="leader-image">
											<img
												src={ fmt.Sprintf("/static/images/team/%s.JPG", url.PathEscape(name)) }
												onError="this.onerror=null; this.src='/static/images/team/default-avatar.jpg';"
												style="width: 100%; height: 100%; object-fit: cover;"
											/>
										</div>
										<div class="leader-content">
											<h4>{ name }</h4>
											<div class="position">{ phrases[sectionName][fmt.Sprintf("teacher%d_%d_position", row, col)] }</div>
											<div class="email"><a href={ templ.SafeURL("mailto:" + phrases[sectionName][fmt.Sprintf("teacher%d_%d_email", row, col)]) }>{ phrases[sectionName][fmt.Sprintf("teacher%d_%d_email", row, col)] }</a></div>
										</div>
									</div>
								</div>
							}
						}
					</div>
				}
				<hr class="section-divider mb-5"/>
			}
		</div>
	</section>
}

// Helper function to get sorted section names from the phrases map
func getSectionNames(phrases map[string]map[string]string) []string {
	// Sections to exclude from this component
	excludedSections := map[string]bool{
		"header":   true,
		"hero":     true,
		"director": true,
		"deputies": true,
	}

	sections := make([]string, 0, len(phrases))
	for section := range phrases {
		// Skip sections that are in the excluded list
		if excludedSections[section] {
			continue
		}

		// Only include sections that have title and subtitle
		if _, hasTitle := phrases[section]["title"]; hasTitle {
			if _, hasSubtitle := phrases[section]["subtitle"]; hasSubtitle {
				sections = append(sections, section)
			}
		}
	}
	sort.Strings(sections)
	return sections
}
