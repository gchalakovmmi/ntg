package team

import (
	"fmt"
	"net/url"
	"sort"
)

templ methodicalAssociations(phrases map[string]map[string]string) {
	<section class="section leadership-section">
		<div class="container">
			for _, sectionName := range getSectionNames(phrases) {
				<div class="section-title animate-on-scroll">
					<h2>{ phrases[sectionName]["title"] }</h2>
					<p>{ phrases[sectionName]["subtitle"] }</p>
				</div>
				for row := 1; row <= 3; row++ {
					<div class="row g-4 mb-5">
						for col := 1; col <= 4; col++ {
							// Try to find entries with "teacher" prefix first
							if name, exists := phrases[sectionName][fmt.Sprintf("teacher%d_%d_name", row, col)]; exists {
								<div class="col-lg-3 col-md-6">
									<div class="leader-card team-card-clickable animate-on-scroll">
										<div class="leader-image">
											<img
												src={ fmt.Sprintf("/static/images/team/%s.JPG", url.PathEscape(name)) }
												onError="this.onerror=null; this.src='/static/images/team/default_user.webp'"
												style="width: 100%; height: 100%; object-fit: cover;"
											/>
										</div>
										<div class="leader-content">
											<h4>{ name }</h4>
											<div class="position">{ phrases[sectionName][fmt.Sprintf("teacher%d_%d_position", row, col)] }</div>
											<div class="email"><a href={ templ.SafeURL("mailto:" + phrases[sectionName][fmt.Sprintf("teacher%d_%d_email", row, col)]) }>{ phrases[sectionName][fmt.Sprintf("teacher%d_%d_email", row, col)] }</a></div>
										</div>
									</div>
								</div>
							} else if name, exists := phrases[sectionName][fmt.Sprintf("staff%d_%d_name", row, col)]; exists {
								// If no "teacher" prefix found, try with "staff" prefix
								<div class="col-lg-3 col-md-6">
									<div class="leader-card team-card-clickable animate-on-scroll">
										<div class="leader-image">
											<img
												src={ fmt.Sprintf("/static/images/team/%s.JPG", url.PathEscape(name)) }
												onError="this.onerror=null; this.src='/static/images/team/default_user.webp';"
												style="width: 100%; height: 100%; object-fit: cover;"
											/>
										</div>
										<div class="leader-content">
											<h4>{ name }</h4>
											<div class="position">{ phrases[sectionName][fmt.Sprintf("staff%d_%d_position", row, col)] }</div>
											<div class="email"><a href={ templ.SafeURL("mailto:" + phrases[sectionName][fmt.Sprintf("staff%d_%d_email", row, col)]) }>{ phrases[sectionName][fmt.Sprintf("staff%d_%d_email", row, col)] }</a></div>
										</div>
									</div>
								</div>
							}
						}
					</div>
				}
				<hr class="section-divider mb-5"/>
			}
		</div>
	</section>
}

// Helper function to get sorted section names from the phrases map
func getSectionNames(phrases map[string]map[string]string) []string {
	// Sections to exclude from this component
	excludedSections := map[string]bool{
		"header":   true,
		"hero":     true,
		"director": true,
		"deputies": true,
	}

	// Staff sections to be placed at the end (in this order)
	staffSections := []string{"support", "admin"}

	// Collect regular sections and check which staff sections exist
	regularSections := make([]string, 0, len(phrases))
	existingStaffSections := make([]string, 0, len(staffSections))

	for section := range phrases {
		// Skip excluded sections
		if excludedSections[section] {
			continue
		}

		// Only include sections that have title and subtitle
		if _, hasTitle := phrases[section]["title"]; !hasTitle {
			continue
		}
		if _, hasSubtitle := phrases[section]["subtitle"]; !hasSubtitle {
			continue
		}

		// Check if it's a staff section
		isStaffSection := false
		for _, staffSec := range staffSections {
			if section == staffSec {
				isStaffSection = true
				existingStaffSections = append(existingStaffSections, section)
				break
			}
		}

		// If not a staff section, add to regular sections
		if !isStaffSection {
			regularSections = append(regularSections, section)
		}
	}

	// Sort the regular sections alphabetically
	sort.Strings(regularSections)

	// Combine: regular sections first, then staff sections in defined order
	result := make([]string, 0, len(regularSections)+len(existingStaffSections))
	result = append(result, regularSections...)

	// Add staff sections in the predefined order (support, admin)
	for _, staffSec := range staffSections {
		for _, existingSec := range existingStaffSections {
			if staffSec == existingSec {
				result = append(result, existingSec)
				break
			}
		}
	}

	return result
}
